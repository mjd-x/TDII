;----------------------COMPLETAR SI O SI ---------------------------------------
; Fecha:
;
; Programador:
;
; Descripción:
;
; Modificaciones:
;
;-------------------------------------------------------------------------------

;----------Archivos Include SON DIRECTIVAS PARA EL CONTROLADOR------------------
$bitdef.h       ;manejo de a bits 
$ioAT89C52.h    ;incluye los registros del microcontrolador
;-------------------------------------------------------------------------------

;--- Se declara el programa -----
         NAME    template ;Nombre del archivo
         PUBLIC  main
;--------------------------------
         
;---- Prototipos de ISRs -------------------------------------------------
   PUBLIC myISR           ;declaro el prototipo de la servicio de atención de Interrupciones.
;-------------------------------------------------------------------------------

;---- Prototipos de subrutinas -------------------------------------------------
   PUBLIC MiSubrutina            ;declaro el prototipo de la subrutina
;-------------------------------------------------------------------------------

;---- Constantes ---------------------------------------------------------------
MI_CONSTANTE     EQU    4              ;Se define la constante en decimal, EQU es una directiva del compilador
CONSTANTE_BIN    EQU   b'00001000    ;define constante en binario.
CONSTANTE_HEX    EQU   0x45           ;define constante en hexadecimal.
   
;Constantes para los segmentos
SEG_CODIGO              EQU     0030h    ; inicio seg codigo
SEG_STACK               EQU     00C0h    ;Segmento de stack

LONG_STACK              EQU     10     ;Longitud en bytes del stack
;-------------------------------------------------------------------------------
;LAS CONSTANTES HAY QUE SACARLAS PARA EL TP SI NO LAS OCUPAS
;---SEGMENTO DE CODIGO----------------------------------------------------------
            ;define el punto de inicio del Programa (code)
            ASEG ;directiva que dice que la proxima direccion es para definir una direccion absoluta
            org 0000h ;es la dirección de inicio
            ljmp    main ;LJMP salto largo al main (main es una etiqueta) 
                       
           
           ;INT TIMER0 vector
           ASEG
           org 000BH                    ;Definir el vector de interrupción
           ljmp myISR                ; Definir el el salto a la ISR
           
           
           
;---SEGMENTO DE STACK----------es donde voy guardando las direcciones donde estaba antes de las subrutinas
;va en la de datos-------------------------------------------------
            ;RSEG ISTACK:IDATA:NOROOT(0)
            aseg
            org SEG_STACK
stack_init  DS  LONG_STACK             ;Define el segmento de stack    defino la variable (array) del tamaño long_stack   
;para saber si es de datos preguntarse si te sirve dsp de q se corte la luz
;---SEGMENTO DE DATOS relocalizable-----------------------------------------------------------
       RSEG    IDATA_Z:DATA:NOROOT ;ponelo donde puedas, el compilador donde tenga lugar 
       
my_variable     ds    1         ;variable interna para uso del código.

Tabla2Pow      db      1,2,4,8,16,32,64   ;forma de definir tabla en RAM.

;---SEGMENTO DE CÓDIGO-----------------------------------------------------------
         RSEG    RCODE
         ORG     SEG_CODIGO                      ;define el punto de inicio del Programa (code) 

;Inicia el código principal
main ;la etiqueta siempre pegada al margen 
        ;Inicializo el STACK
        mov SP,#stack_init-1                      ;inicializo el stack     Primero incremento el SP y dsp guardo  #es para decir que lo guarde en forma inmediata

	
        ;Inicializaciones
   
Loop_ppal:              
          
         ; MOV A, #20 ;muevo al acumulador el valor 20
         ; ADD A, #2 ;le sumo dos al acumulador
          
          
      ;    call MiSubrutina
          ;hago lo que corresponde.
 ;-----------------------EJERCICIO 1--------------------------------------------         
;Realizar la siguiente operación matemática: R3 = [ (R0 + 3Eh) + 1 ]            
 /*           MOV         R0, #0C1h
            MOV         A, R0
            ADD         A, #3EH
            INC         A
            MOV         R1, A
            NOP
*/ ;la diferencia entre ADD e INC es que ADD actualiza el carry pero INC no lo actualiza
 ;-----------------------EJERCICIO 2--------------------------------------------         
; Dividir un número alojado en R1 por 8.
 /*
            MOV         R1, #16
            MOV         B,#8
            MOV         A, R1
            DIV         AB
            MOV         R0, A
            NOP
*/
;-----------------------EJERCICIO 3--------------------------------------------         
; Dividir mediante desplazamiento por 2
/*
            MOV         R1, #16
            MOV         A, R1
            RR          A
            MOV         R0, A
            NOP
*/
;-----------------------EJERCICIO 5--------------------------------------------         
;  Implemente el problema 2 en una subrutina. Analice el comportamiento del microcontrolador cuando se produce el llamado a la subrutina.
/*
            CALL MiSubrutina
            NOP
*/
;-----------------------EJERCICIO 6--------------------------------------------         
;  Aplicar f(x)=3x+7 siendo “x” un valor almacenado en el acumulador (recuerde que el resultado será en dos bytes).. RECORDAR QUE MUL GUARDA EN 2 BYTES, A Y B
 /*          
            MOV         A, #255
            MOV         B, #3
            MUL         AB
            ADD         A,#7
            MOV         DPL, A
            MOV         A,B
            ADDC        A,#0H
            MOV         DPH, A
            NOP
            
    ;¿Que pasa cuando elijo un numero que me lleva a que se desborde varias veces el carry?
*/
;-----------------------EJERCICIO 7--------------------------------------------         
;Sumar dos números de 16 bits, alojados en R4:R3 y R6:R5 (parte alta : parte baja), y guardar el resultado en el DPTR.           
/*
            MOV         R4, #0FH  ; parte alta   4095
            MOV         R3, #0FFH  ; parte baja
            MOV         R6, #0FH  ; parte alta   4095
            MOV         R5, #0FFH  ; parte baja
            MOV         A, R3
            ADD         A, R5
            MOV         R7, A
            MOV         A, R4
            ADDC        A, R6
            MOV         DPH,A    
            MOV         DPL, R7
            NOP
*/
;-----------------------EJERCICIO 8--------------------------------------------         
;Usando como base el problema anterior sume los valores FEE7h a 001Ah y almacenar el resultado en el DPTR.           
/*
            MOV         R4, #0FEH  ; parte alta   FEE7h
            MOV         R3, #0E7H  ; parte baja
            MOV         R6, #00H  ; parte alta   001Ah
            MOV         R5, #1AH  ; parte baja
            MOV         A, R3
            ADD         A, R5
            MOV         R7, A
            MOV         A, R4
            ADDC        A, R6
            MOV         DPH, A
            MOV         DPL, R7    
            NOP
*/            
;-----------------------EJERCICIO 9--------------------------------------------         
;El contenido del acumulador posee un valor numérico (0 a 9), convertirlo al equivalente carácter según el código ASCII (Por ejemplo: si el valor es ACC = 03h, el resultado es el carácter ‘3’).           
/*
            MOV         A, #3  
            ADD         A, #30H
            NOP
*/
;-----------------------EJERCICIO 10--------------------------------------------         
;Representar el valor de un byte en sus caracteres ASCII equivalente, guardar el resultado en DPTR. (Ejemplo: 34h?Debe convertirse a ‘3’ ‘4’).
;Recibir un numero en hexa y ese numero pasarlo al DPTR
/*
            MOV         A, #34H
            MOV         R2, A
            MOV         B, #00001111B
            ANL         A, B
            ADD         A,#30H
            MOV         DPL, A
            MOV         A,R2
            SWAP        A
            ANL         A, B
            ADD         A, #30H
            MOV         DPH, A
            NOP
 */
;-----------------------EJERCICIO 12--------------------------------------------         
;Sumar el contenido de lo ingresado en P0 con el valor del puerto P1 y guardarlo en el registro B.
/*
            MOV         P0, #255 
            MOV         P1, #3 
            MOV         A,P0
            ADDC        A, P1
            MOV         B, A
            NOP
  
  ;¿Al psar directamente en P0y P1 no tengo informacion en los registros?
*/
;-----------------------EJERCICIO PENSADO POR MI--------------------------------------------         
;Sumar dos numeros de 8bits y almacenarlos en DPTR.
/*
            MOV         B, #255 
            MOV         A, #255 
            ADD         A, B
            MOV         DPL, A
            MOV         A, #0
            ADDC        A, DPH
            MOV         DPH, A
            NOP
*/
  
;salir:  jmp     Loop_ppal
;--------fin del main-----------------------------------------------

;-------Subrutinas--------------------------------------------------------------
        RSEG NEAR_CODE:CODE:NOROOT(0) ;segmento relocalizable para subrutinas
        
;===========SUBRUTINAS==========================================================
;-------------------------------------------------------------------------------
; Nombre: MiSubrutina
; Parametros:ninguno
; Devuelve: nada
; Modifica:
;       ????
; Nivel de Stack: ?
; Descripción:
;       Descripción de funcionamiento de la subrutina.
;-------------------------------------------------------------------------------
MiSubrutina:
/*
            MOV         R1, #16
            MOV         B,#8
            MOV         A, R1
            DIV         AB
            MOV         R0, A
            NOP
*/
    ret

;===ISRs========================================================================
;-------------------------------------------------------------------------------
; Nombre: myISR
; Parametros:ninguno
; Devuelve:nada
; Modifica:
;       xxxxx
; Nivel de Stack:
;
; Descripción:
;       Rutina de servicio de interrupción del <periférico x>
;-------------------------------------------------------------------------------  
 myISR:
 
   reti

;FIN DEL ARCHIVO
  END main   ;Cierra el archivo
